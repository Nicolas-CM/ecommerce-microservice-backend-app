name: CI-CD Stage - Full Validation & Deploy

permissions:
  contents: write
  packages: write
  id-token: write
  security-events: write

on:
  push:
    branches: [stage]
  pull_request:
    branches: [stage]
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  IMAGE_PREFIX: ${{ github.repository_owner }}

# NOTE: This Stage pipeline does NOT generate or bump versions. The canonical image tags for Stage
# are stored in `k8s/helm/image-tags-stage.yaml` and are controlled manually via commits/PRs to the
# `stage` branch. Dev builds are responsible for producing/tagging Docker images and creating Git
# tags; Stage will only deploy what is declared in `image-tags-stage.yaml`.

jobs:
  # ============================================================================
  # BUILD & TEST CON SONARQUBE (como flamini)
  # ============================================================================
  maven-build:
    name: üî® Build & Unit Tests
    runs-on: ubuntu-latest
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: üß≠ Normalize Image Owner (lowercase)
        run: |
          OWNER_LOWER=$(echo "$IMAGE_PREFIX" | tr '[:upper:]' '[:lower:]')
          echo "OWNER_LOWER=$OWNER_LOWER" >> $GITHUB_ENV
        env:
          IMAGE_PREFIX: ${{ env.IMAGE_PREFIX }}

      - name: üß≠ Normalize Image Owner (lowercase)
        run: |
          OWNER_LOWER=$(echo "$IMAGE_PREFIX" | tr '[:upper:]' '[:lower:]')
          echo "OWNER_LOWER=$OWNER_LOWER" >> $GITHUB_ENV
        env:
          IMAGE_PREFIX: ${{ env.IMAGE_PREFIX }}

      - name: ‚òï Set up JDK 11 and 17
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: |
            11
            17

      - name: üî® Build with Maven (unit tests)
        env:
          JAVA_HOME: ${{ env.JAVA_HOME_11_X64 }}
        run: |
          echo "Building with Java 11"
          echo "JAVA_HOME: $JAVA_HOME"
          java -version
          chmod +x ./mvnw
          ./mvnw -B -T 1C verify -Dtest="*ServiceImplTest" -DfailIfNoTests=false

      - name: üìä SonarQube Analysis
        env:
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          JAVA_HOME: ${{ env.JAVA_HOME_17_X64 }}
        run: |
          # Check if secrets are set
          if [ -z "$SONAR_TOKEN" ] || [ -z "$SONAR_HOST_URL" ]; then
            echo "‚ö†Ô∏è  SONAR_HOST_URL or SONAR_TOKEN not set; skipping SonarQube analysis"
            exit 0
          fi

          # Validate URL scheme
          if [[ ! "$SONAR_HOST_URL" =~ ^https?:// ]]; then
            echo "‚ö†Ô∏è  SONAR_HOST_URL does not start with http:// or https://; skipping"
            echo "   Current value: '$SONAR_HOST_URL'"
            exit 0
          fi

          echo "‚û°Ô∏è  Running SonarQube analysis against $SONAR_HOST_URL"
          echo "   JAVA_HOME: $JAVA_HOME"
          echo "   Java version: $(java -version 2>&1 | head -n 1)"
          
          chmod +x ./mvnw
          
          # Check if using SonarCloud (requires organization)
          if [[ "$SONAR_HOST_URL" == *"sonarcloud.io"* ]]; then
            echo "Using SonarCloud - organization parameter required"
            ./mvnw -B -DskipTests=true sonar:sonar \
              -Dsonar.host.url="$SONAR_HOST_URL" \
              -Dsonar.login="$SONAR_TOKEN" \
              -Dsonar.organization="nicolas-cm" \
              -Dsonar.projectKey="Nicolas-CM_ecommerce-microservice-backend-app" \
              -Dsonar.projectName="ecommerce-microservice-backend-app" \
              -Dsonar.coverage.jacoco.xmlReportPaths="**/target/site/jacoco/jacoco.xml,**/target/site/jacoco-aggregate/jacoco.xml"
          else
            echo "Using self-hosted SonarQube"
            ./mvnw -B -DskipTests=true sonar:sonar \
              -Dsonar.host.url="$SONAR_HOST_URL" \
              -Dsonar.login="$SONAR_TOKEN" \
              -Dsonar.projectKey="ecommerce-stage" \
              -Dsonar.projectName="ecommerce-stage" \
              -Dsonar.coverage.jacoco.xmlReportPaths="**/target/site/jacoco/jacoco.xml,**/target/site/jacoco-aggregate/jacoco.xml"
          fi

      - name: üì§ Upload test reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          path: |
            **/target/surefire-reports/*.xml
          retention-days: 3

      - name: üì¶ Upload build workspace
        uses: actions/upload-artifact@v4
        with:
          name: workspace
          path: |
            .
            !.git
          retention-days: 1

  # ============================================================================
  # TRIVY SECURITY SCAN
  # ============================================================================
  trivy-scan:
    name: üîí Trivy Security Scan
    runs-on: ubuntu-latest
    needs: maven-build
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üß≠ Normalize Image Owner (lowercase)
        run: |
          OWNER_LOWER=$(echo "$IMAGE_PREFIX" | tr '[:upper:]' '[:lower:]')
          echo "OWNER_LOWER=$OWNER_LOWER" >> $GITHUB_ENV
        env:
          IMAGE_PREFIX: ${{ env.IMAGE_PREFIX }}

      - name: üîç Run Trivy Filesystem Scan
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-repo-scan.sarif'
          severity: 'CRITICAL,HIGH'

      - name: üì§ Upload Trivy SARIF to GitHub Security
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-repo-scan.sarif'

      - name: üì¶ Save Trivy Report as Artifact
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: trivy-repo-scan
          path: trivy-repo-scan.sarif

  # NOTE: Stage should NOT generate/assign versions; Dev workflow is responsible for building and producing tags.
  # The Stage pipeline uses `k8s/helm/image-tags-stage.yaml` as the canonical source for image tags and will
  # deploy based on that file only. All automated stage versioning logic and outputs have been removed.

  # ============================================================================
  # DOCKER BUILD & PUSH
  # ============================================================================
  # No Docker builds in Stage pipeline; builds happen on `dev` workflows per microservice

  # ============================================================================
  # DEPLOY TO AKS STAGE
  # ============================================================================
  kubernetes-deploy:
    name: üöÄ Deploy to AKS Stage
    runs-on: ubuntu-latest
    needs: [maven-build, trivy-scan]
    environment: ecommerce-stage
    if: github.event_name == 'push' && github.ref == 'refs/heads/stage'
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üîê Azure Login
        uses: azure/login@v1
        with:
          creds: |
            {
              "clientId": "${{ secrets.AZURE_CLIENT_ID }}",
              "clientSecret": "${{ secrets.AZURE_CLIENT_SECRET }}",
              "subscriptionId": "${{ secrets.AZURE_SUBSCRIPTION_ID }}",
              "tenantId": "${{ secrets.AZURE_TENANT_ID }}"
            }

      - name: ‚öôÔ∏è Set AKS Context
        uses: azure/aks-set-context@v3
        with:
          resource-group: ${{ secrets.AKS_RG }}
          cluster-name: ${{ secrets.AKS_NAME }}

      - name: üß≠ Normalize Image Owner (lowercase)
        run: |
          OWNER_LOWER=$(echo "${{ env.IMAGE_PREFIX }}" | tr '[:upper:]' '[:lower:]')
          echo "OWNER_LOWER=${OWNER_LOWER}" >> $GITHUB_ENV
        env:
          IMAGE_PREFIX: ${{ env.IMAGE_PREFIX }}

      - name: Install kubectl
        uses: azure/setup-kubectl@v3

      - name: Install Helm
        uses: azure/setup-helm@v4
        with:
          version: 'latest'

      - name: üß© Ensure jq is installed
        run: |
          sudo apt-get update && sudo apt-get install -y jq || true

      - name: Create namespace `ecommerce-stage`
        run: |
          kubectl create namespace ecommerce-stage --dry-run=client -o yaml | kubectl apply -f -
          echo "Namespace ecommerce-stage ready"
          kubectl get namespace ecommerce-stage

      - name: Create GHCR secret (if provided)
        run: |
          if [ -n "${{ secrets.GHCR_TOKEN }}" ]; then
            kubectl create secret docker-registry ghcr-secret --docker-server=ghcr.io --docker-username=${{ secrets.GHCR_USERNAME }} --docker-password=${{ secrets.GHCR_TOKEN }} --namespace=ecommerce-stage || true
          else
            echo "GHCR_TOKEN not provided, skipping secret creation"
          fi

      - name: üîÑ Deploy Helm chart to Stage (Helm upgrade/install)
        working-directory: k8s/helm
        run: |
          echo "Deploying Helm chart to namespace ecommerce-stage..."
          echo "Using image tags from k8s/helm/image-tags-stage.yaml (user-controlled)"

          echo "Using image tags from k8s/helm/image-tags-stage.yaml (user-controlled)"

          # Clean up failed or pending releases similar to the DEV pipeline behavior
          if helm list -n ecommerce-stage | grep -q ecommerce-microservices; then
            RELEASE_STATUS=$(helm status ecommerce-microservices -n ecommerce-stage -o json | jq -r '.info.status')
            echo "Found release with status: $RELEASE_STATUS"
            if [ "$RELEASE_STATUS" = "failed" ] || [ "$RELEASE_STATUS" = "pending-install" ] || [ "$RELEASE_STATUS" = "pending-upgrade" ]; then
              echo "Cleaning up failed/pending release..."
              helm uninstall ecommerce-microservices -n ecommerce-stage || true
              sleep 5
            fi
          else
            echo "No existing release found"
          fi

          # Always include the image-tags file so Helm has the canonical tags
          helm upgrade --install ecommerce-microservices ./ecommerce-chart \
            --namespace ecommerce-stage \
            --values ./ecommerce-chart/values.yaml \
            --values ./image-tags-stage.yaml \
            --set global.environment=stage \
            --wait --timeout 20m

      - name: ‚è≥ Wait for Rollouts
        run: |
          declare -a SERVICES=(
            "api-gateway"
            "cloud-config"
            "service-discovery"
            "proxy-client"
            "user-service"
            "product-service"
            "order-service"
            "payment-service"
            "shipping-service"
            "favourite-service"
          )
          
          FAILED_DEPLOYMENTS=()
          
          for SERVICE in "${SERVICES[@]}"; do
            if kubectl get deployment ${SERVICE} -n ecommerce-stage 2>/dev/null; then
              echo "‚è≥ Waiting for $SERVICE rollout..."
              
              if kubectl rollout status deployment/${SERVICE} -n ecommerce-stage --timeout=10m; then
                echo "‚úÖ $SERVICE rolled out successfully"
              else
                echo "‚ùå $SERVICE rollout failed"
                FAILED_DEPLOYMENTS+=("$SERVICE")
              fi
            fi
          done
          
          if [ ${#FAILED_DEPLOYMENTS[@]} -gt 0 ]; then
            echo "‚ùå Failed deployments: ${FAILED_DEPLOYMENTS[@]}"
            exit 1
          fi
          
          echo "‚úÖ All deployments completed successfully"

      - name: üîç Verify Services
        run: |
          echo "üìã Final Kubernetes State:"
          kubectl get deployments -n ecommerce-stage
          kubectl get pods -n ecommerce-stage -o wide
          kubectl get services -n ecommerce-stage

  # ============================================================================
  # E2E TESTS (Postman/Newman)
  # ============================================================================
  e2e-tests:
    name: üß™ E2E Tests
    runs-on: ubuntu-latest
    needs: [kubernetes-deploy]
    if: github.event_name == 'push' && github.ref == 'refs/heads/stage'
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üì¶ Install Newman
        run: |
          npm install -g newman
          npm install -g newman-reporter-htmlextra

      - name: üîê Azure Login
        uses: azure/login@v1
        with:
          creds: |
            {
              "clientId": "${{ secrets.AZURE_CLIENT_ID }}",
              "clientSecret": "${{ secrets.AZURE_CLIENT_SECRET }}",
              "subscriptionId": "${{ secrets.AZURE_SUBSCRIPTION_ID }}",
              "tenantId": "${{ secrets.AZURE_TENANT_ID }}"
            }

      - name: ‚öôÔ∏è Set AKS Context
        uses: azure/aks-set-context@v3
        with:
          resource-group: ${{ secrets.AKS_RG }}
          cluster-name: ${{ secrets.AKS_NAME }}

      - name: üåê Get API Gateway IP
        id: get-ip
        run: |
          echo "Getting API Gateway External IP..."
          for i in {1..30}; do
            EXTERNAL_IP=$(kubectl get svc api-gateway -n ecommerce-stage -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
            if [ ! -z "$EXTERNAL_IP" ]; then
              echo "EXTERNAL_IP=$EXTERNAL_IP" >> $GITHUB_ENV
              echo "‚úÖ API Gateway IP: $EXTERNAL_IP"
              break
            fi
            echo "‚è≥ Waiting for IP... ($i/30)"
            sleep 10
          done
          
          if [ -z "$EXTERNAL_IP" ]; then
            echo "‚ùå Failed to get External IP"
            exit 1
          fi

      - name: ‚è≥ Wait for Services Ready
        run: |
          echo "Waiting for services to be ready..."
          
          declare -a ENDPOINTS=(
            "http://$EXTERNAL_IP:8080/actuator/health"
            "http://$EXTERNAL_IP:8080/user-service/actuator/health"
            "http://$EXTERNAL_IP:8080/product-service/actuator/health"
          )
          
          for endpoint in "${ENDPOINTS[@]}"; do
            for i in {1..20}; do
              STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$endpoint" 2>/dev/null || echo "000")
              if [ "$STATUS" = "200" ]; then
                echo "‚úÖ $endpoint is ready"
                break
              fi
              echo "‚è≥ Waiting for $endpoint... ($i/20)"
              sleep 5
            done
          done

      - name: üß™ Run E2E Tests
        run: |
          echo "Running E2E tests against http://$EXTERNAL_IP:8080"
          
          if [ ! -f "postman-collections/E2E Ecommerce Microservices Tests.postman_collection.json" ]; then
            echo "‚ö†Ô∏è  Postman collection not found, skipping E2E tests"
            exit 0
          fi
          
          mkdir -p test-reports
          
          newman run "postman-collections/E2E Ecommerce Microservices Tests.postman_collection.json" \
            --env-var "baseUrl=http://$EXTERNAL_IP:8080" \
            --reporters cli,htmlextra \
            --reporter-htmlextra-export "test-reports/e2e-report.html" \
            --delay-request 500 \
            --timeout-request 10000 || echo "‚ö†Ô∏è  Some E2E tests failed"

      - name: üì§ Upload E2E Results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: e2e-test-results
          path: test-reports/
          retention-days: 7

  # ============================================================================
  # PERFORMANCE TESTS (Locust)
  # ============================================================================
  performance-tests:
    name: üìä Performance Tests
    runs-on: ubuntu-latest
    needs: [kubernetes-deploy]
    if: github.event_name == 'push' && github.ref == 'refs/heads/stage'
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üêç Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: üì¶ Install Locust
        run: |
          pip install -r tests/performance/requirements.txt

      - name: üîê Azure Login
        uses: azure/login@v1
        with:
          creds: |
            {
              "clientId": "${{ secrets.AZURE_CLIENT_ID }}",
              "clientSecret": "${{ secrets.AZURE_CLIENT_SECRET }}",
              "subscriptionId": "${{ secrets.AZURE_SUBSCRIPTION_ID }}",
              "tenantId": "${{ secrets.AZURE_TENANT_ID }}"
            }

      - name: ‚öôÔ∏è Set AKS Context
        uses: azure/aks-set-context@v3
        with:
          resource-group: ${{ secrets.AKS_RG }}
          cluster-name: ${{ secrets.AKS_NAME }}

      - name: üåê Get API Gateway IP
        id: get-ip
        run: |
          for i in {1..30}; do
            EXTERNAL_IP=$(kubectl get svc api-gateway -n ecommerce-stage -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
            if [ ! -z "$EXTERNAL_IP" ]; then
              echo "API_GATEWAY_URL=http://$EXTERNAL_IP:8080" >> $GITHUB_ENV
              echo "‚úÖ API Gateway: http://$EXTERNAL_IP:8080"
              break
            fi
            sleep 10
          done

      - name: üöÄ Run Locust Performance Tests
        run: |
          cd tests/performance
          locust -f locustfile.py \
            --host=$API_GATEWAY_URL \
            --users 10 \
            --spawn-rate 2 \
            --run-time 1m \
            --headless \
            --html=locust-report.html \
            --csv=locust-stats

      - name: üì§ Upload Performance Results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: performance-test-results
          path: tests/performance/locust-*
          retention-days: 7

  # ============================================================================
  # OWASP ZAP SECURITY SCAN
  # ============================================================================
  security-tests:
    name: üîê OWASP ZAP Security Scan
    runs-on: ubuntu-latest
    needs: [kubernetes-deploy]
    if: github.event_name == 'push' && github.ref == 'refs/heads/stage'
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üîê Azure Login
        uses: azure/login@v1
        with:
          creds: |
            {
              "clientId": "${{ secrets.AZURE_CLIENT_ID }}",
              "clientSecret": "${{ secrets.AZURE_CLIENT_SECRET }}",
              "subscriptionId": "${{ secrets.AZURE_SUBSCRIPTION_ID }}",
              "tenantId": "${{ secrets.AZURE_TENANT_ID }}"
            }

      - name: ‚öôÔ∏è Set AKS Context
        uses: azure/aks-set-context@v3
        with:
          resource-group: ${{ secrets.AKS_RG }}
          cluster-name: ${{ secrets.AKS_NAME }}

      - name: üåê Get API Gateway IP
        id: get-ip
        run: |
          for i in {1..30}; do
            EXTERNAL_IP=$(kubectl get svc api-gateway -n ecommerce-stage -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
            if [ ! -z "$EXTERNAL_IP" ]; then
              echo "TARGET_URL=http://$EXTERNAL_IP:8080" >> $GITHUB_ENV
              echo "‚úÖ Target: http://$EXTERNAL_IP:8080"
              break
            fi
            sleep 10
          done

      - name: üîç Run OWASP ZAP Baseline Scan
        uses: zaproxy/action-baseline@v0.12.0
        with:
          target: ${{ env.TARGET_URL }}
          rules_file_name: '.zap/rules.tsv'
          cmd_options: '-a'

      - name: üì§ Upload ZAP Results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: zap-scan-results
          path: |
            report_html.html
            report_md.md
          retention-days: 7

  # Note: Stage no longer creates GitHub Releases; releases & versioning are handled by Dev builds and git tags

  # ============================================================================
  # NOTIFY ON FAILURE
  # ============================================================================
  notify-failure:
    name: üìß Notify Failure
    runs-on: ubuntu-latest
    needs: [maven-build, trivy-scan, kubernetes-deploy, e2e-tests, performance-tests, security-tests]
    if: failure()
    steps:
      - name: üìß Send Failure Email
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: smtp.gmail.com
          server_port: 587
          username: ${{ secrets.MAIL_USERNAME }}
          password: ${{ secrets.MAIL_PASSWORD }}
          subject: "‚ùå Stage Pipeline Failed - ${{ github.repository }}"
          to: ${{ secrets.MAIL_TO }}
          from: GitHub Actions
          body: |
            Stage Pipeline Failed!
            
            Repository: ${{ github.repository }}
            Branch: ${{ github.ref_name }}
            Commit: ${{ github.sha }}
            Workflow: ${{ github.workflow }}
            Triggered by: ${{ github.actor }}
            
            Please check the logs for details:
            https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}
