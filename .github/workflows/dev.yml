name: DEV - Tests & Deploy

on:
  push:
    branches: [ dev ]
  pull_request:
    branches: [ dev ]
  workflow_dispatch:

jobs:
  unit-tests:
    name: Unit Tests
    runs-on: ubuntu-latest
    strategy:
      fail-fast: true
      matrix:
        service: [ 'user-service', 'product-service', 'order-service', 'payment-service', 'shipping-service', 'favourite-service' ]

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up JDK 11
        uses: actions/setup-java@v3
        with:
          distribution: temurin
          java-version: '11'
          cache: maven

      - name: Run unit tests for ${{ matrix.service }}
        run: |
          chmod +x ./mvnw || true
          ./mvnw -pl ${{ matrix.service }} -am test

      - name: Publish unit test results
        uses: dorny/test-reporter@v1
        if: always()
        with:
          name: Unit Tests - ${{ matrix.service }}
          path: ${{ matrix.service }}/target/surefire-reports/*.xml
          reporter: java-junit
          fail-on-error: true

  integration-tests:
    name: Integration Tests
    runs-on: ubuntu-latest
    needs: unit-tests
    strategy:
      fail-fast: true
      matrix:
        include:
          - module: user-service
            test: UserControllerIntegrationTest
          - module: payment-service
            test: PaymentServiceIntegrationTest
          - module: favourite-service
            test: FavouriteServiceIntegrationTest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up JDK 11
        uses: actions/setup-java@v3
        with:
          distribution: temurin
          java-version: '11'
          cache: maven

      - name: Run integration test ${{ matrix.test }} in ${{ matrix.module }}
        run: |
          chmod +x ./mvnw || true
          echo "Running integration test '${{ matrix.test }}' in module '${{ matrix.module }}'"
          ./mvnw -pl ${{ matrix.module }} -am -Dtest=${{ matrix.test }} -DfailIfNoTests=false test

      - name: Publish integration test results
        uses: dorny/test-reporter@v1
        if: always()
        with:
          name: Integration Tests - ${{ matrix.module }}
          path: ${{ matrix.module }}/target/surefire-reports/*.xml
          reporter: java-junit
          fail-on-error: true

  deploy:
    name: Deploy to AKS dev
    runs-on: ubuntu-latest
    needs: integration-tests
    if: github.ref == 'refs/heads/dev'
    environment: dev
    env:
      ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
      ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
      ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
      TF_VERSION: '1.7.0'
      ENVIRONMENT: 'dev'
      AKS_NAME: ${{ secrets.AKS_NAME }}
      AKS_RG: ${{ secrets.AKS_RG }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: |
            {
              "clientId": "${{ secrets.AZURE_CLIENT_ID }}",
              "clientSecret": "${{ secrets.AZURE_CLIENT_SECRET }}",
              "subscriptionId": "${{ secrets.AZURE_SUBSCRIPTION_ID }}",
              "tenantId": "${{ secrets.AZURE_TENANT_ID }}"
            }

      - name: Get AKS credentials
        run: |
          if [ -z "${{ secrets.AKS_NAME }}" ]; then
            echo "ERROR: secret AKS_NAME is not set. Please add repository or environment secret 'AKS_NAME' with your AKS cluster name.";
            exit 1;
          fi
          if [ -z "${{ secrets.AKS_RG }}" ]; then
            echo "ERROR: secret AKS_RG is not set. Please add repository or environment secret 'AKS_RG' with your AKS resource group name.";
            exit 1;
          fi
          echo "Getting credentials for AKS cluster: ${{ secrets.AKS_NAME }} in RG: ${{ secrets.AKS_RG }}"
          az aks get-credentials --resource-group "${{ secrets.AKS_RG }}" --name "${{ secrets.AKS_NAME }}" --overwrite-existing
          echo "Current context:"
          kubectl config current-context
          echo "Cluster nodes:"
          kubectl get nodes --no-headers | wc -l
          echo "nodes available"

      - name: Install kubectl
        uses: azure/setup-kubectl@v3

      - name: Install Helm
        uses: azure/setup-helm@v4
        with:
          version: 'latest'

      - name: Create namespace
        run: |
          kubectl create namespace ecommerce-dev --dry-run=client -o yaml | kubectl apply -f -
          echo "Namespace ecommerce-dev ready"
          kubectl get namespace ecommerce-dev

      - name: Create GHCR secret (if provided)
        run: |
          if [ -n "${{ secrets.GHCR_TOKEN }}" ]; then \
            kubectl create secret docker-registry ghcr-secret --docker-server=ghcr.io --docker-username=${{ secrets.GHCR_USERNAME }} --docker-password=${{ secrets.GHCR_TOKEN }} --namespace=ecommerce-dev || true; \
          else \
            echo "GHCR_TOKEN not provided, skipping secret creation"; \
          fi

      - name: Check and cleanup failed releases
        working-directory: k8s/helm
        run: |
          echo "Checking for existing releases..."
          if helm list -n ecommerce-dev | grep -q ecommerce-microservices; then
            RELEASE_STATUS=$(helm status ecommerce-microservices -n ecommerce-dev -o json | jq -r '.info.status')
            echo "Found release with status: $RELEASE_STATUS"
            if [ "$RELEASE_STATUS" = "failed" ] || [ "$RELEASE_STATUS" = "pending-install" ] || [ "$RELEASE_STATUS" = "pending-upgrade" ]; then
              echo "Cleaning up failed/pending release..."
              helm uninstall ecommerce-microservices -n ecommerce-dev || true
              sleep 5
            fi
          else
            echo "No existing release found"
          fi

      - name: Deploy Helm chart
        working-directory: k8s/helm
        run: |
          echo "Deploying Helm chart to namespace ecommerce-dev..."
          
          # Obtener las Ãºltimas versiones de las imÃ¡genes desde GHCR
          # Estas fueron pusheadas por los workflows de build con tags como 0.1.0-dev.38191eb
          echo "ðŸ” Detecting latest image versions from GHCR..."
          
          # FunciÃ³n para obtener el Ãºltimo tag versionado (no dev-latest)
          get_latest_version() {
            SERVICE=$1
            # Obtener todos los tags y filtrar por formato X.Y.Z-dev.SHA
            LATEST=$(gh api \
              -H "Accept: application/vnd.github+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              "/orgs/${{ github.repository_owner }}/packages/container/${SERVICE}/versions" \
              --jq '[.[] | select(.metadata.container.tags[] | test("^[0-9]+\\.[0-9]+\\.[0-9]+-dev\\.[a-f0-9]+$")) | .metadata.container.tags[] | select(test("^[0-9]+\\.[0-9]+\\.[0-9]+-dev\\.[a-f0-9]+$"))][0]' 2>/dev/null || echo "dev-latest")
            echo "$LATEST"
          }
          
          # Detectar versiones de cada servicio
          API_GATEWAY_TAG=$(get_latest_version "api-gateway")
          CLOUD_CONFIG_TAG=$(get_latest_version "cloud-config")
          SERVICE_DISCOVERY_TAG=$(get_latest_version "service-discovery")
          USER_SERVICE_TAG=$(get_latest_version "user-service")
          PRODUCT_SERVICE_TAG=$(get_latest_version "product-service")
          ORDER_SERVICE_TAG=$(get_latest_version "order-service")
          PAYMENT_SERVICE_TAG=$(get_latest_version "payment-service")
          SHIPPING_SERVICE_TAG=$(get_latest_version "shipping-service")
          FAVOURITE_SERVICE_TAG=$(get_latest_version "favourite-service")
          PROXY_CLIENT_TAG=$(get_latest_version "proxy-client")
          
          echo "ðŸ“¦ Using image versions:"
          echo "  api-gateway: $API_GATEWAY_TAG"
          echo "  cloud-config: $CLOUD_CONFIG_TAG"
          echo "  service-discovery: $SERVICE_DISCOVERY_TAG"
          echo "  user-service: $USER_SERVICE_TAG"
          echo "  product-service: $PRODUCT_SERVICE_TAG"
          echo "  order-service: $ORDER_SERVICE_TAG"
          echo "  payment-service: $PAYMENT_SERVICE_TAG"
          echo "  shipping-service: $SHIPPING_SERVICE_TAG"
          echo "  favourite-service: $FAVOURITE_SERVICE_TAG"
          echo "  proxy-client: $PROXY_CLIENT_TAG"
          
          # Deploy con Helm usando los tags versionados dinÃ¡micamente
          helm upgrade --install ecommerce-microservices ./ecommerce-chart \
            --namespace ecommerce-dev \
            --values ./ecommerce-chart/values.yaml \
            --values ./image-tags-dev.yaml \
            --set global.environment=${{ env.ENVIRONMENT }} \
            --set imageTags.api-gateway="$API_GATEWAY_TAG" \
            --set imageTags.cloud-config="$CLOUD_CONFIG_TAG" \
            --set imageTags.service-discovery="$SERVICE_DISCOVERY_TAG" \
            --set imageTags.user-service="$USER_SERVICE_TAG" \
            --set imageTags.product-service="$PRODUCT_SERVICE_TAG" \
            --set imageTags.order-service="$ORDER_SERVICE_TAG" \
            --set imageTags.payment-service="$PAYMENT_SERVICE_TAG" \
            --set imageTags.shipping-service="$SHIPPING_SERVICE_TAG" \
            --set imageTags.favourite-service="$FAVOURITE_SERVICE_TAG" \
            --set imageTags.proxy-client="$PROXY_CLIENT_TAG" \
            --wait \
            --timeout 20m
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Verify deployment
        if: always()
        run: |
          echo "=== Helm Release Status ==="
          helm status ecommerce-microservices -n ecommerce-dev || echo "Release not found"
          echo ""
          echo "=== Pods Status ==="
          kubectl get pods -n ecommerce-dev -o wide
          echo ""
          echo "=== Services ==="
          kubectl get svc -n ecommerce-dev
          echo ""
          echo "=== Recent Events ==="
          kubectl get events -n ecommerce-dev --sort-by='.lastTimestamp' | tail -n 20
