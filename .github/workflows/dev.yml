name: DEV - Tests & Deploy

on:
  push:
    branches: [ dev ]
  pull_request:
    branches: [ dev ]
  workflow_dispatch:

jobs:
  unit-tests:
    name: Unit Tests
    runs-on: ubuntu-latest
    strategy:
      fail-fast: true
      matrix:
        service: [ 'user-service', 'product-service', 'order-service', 'payment-service', 'shipping-service', 'favourite-service' ]

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up JDK 11
        uses: actions/setup-java@v3
        with:
          distribution: temurin
          java-version: '11'
          cache: maven

      - name: Run unit tests for ${{ matrix.service }}
        run: |
          chmod +x ./mvnw || true
          ./mvnw -pl ${{ matrix.service }} -am test

      - name: Publish unit test results
        uses: dorny/test-reporter@v1
        if: always()
        with:
          name: Unit Tests - ${{ matrix.service }}
          path: ${{ matrix.service }}/target/surefire-reports/*.xml
          reporter: java-junit
          fail-on-error: true

  integration-tests:
    name: Integration Tests
    runs-on: ubuntu-latest
    needs: unit-tests
    strategy:
      fail-fast: true
      matrix:
        include:
          - module: user-service
            test: UserControllerIntegrationTest
          - module: payment-service
            test: PaymentServiceIntegrationTest
          - module: favourite-service
            test: FavouriteServiceIntegrationTest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up JDK 11
        uses: actions/setup-java@v3
        with:
          distribution: temurin
          java-version: '11'
          cache: maven

      - name: Run integration test ${{ matrix.test }} in ${{ matrix.module }}
        run: |
          chmod +x ./mvnw || true
          echo "Running integration test '${{ matrix.test }}' in module '${{ matrix.module }}'"
          ./mvnw -pl ${{ matrix.module }} -am -Dtest=${{ matrix.test }} -DfailIfNoTests=false test

      - name: Publish integration test results
        uses: dorny/test-reporter@v1
        if: always()
        with:
          name: Integration Tests - ${{ matrix.module }}
          path: ${{ matrix.module }}/target/surefire-reports/*.xml
          reporter: java-junit
          fail-on-error: true

  deploy:
    name: Deploy to AKS dev
    runs-on: ubuntu-latest
    needs: integration-tests
    if: github.ref == 'refs/heads/dev'
    environment: dev
    env:
      ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
      ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
      ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
      TF_VERSION: '1.7.0'
      ENVIRONMENT: 'dev'
      AKS_NAME: ${{ secrets.AKS_NAME }}
      AKS_RG: ${{ secrets.AKS_RG }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: |
            {
              "clientId": "${{ secrets.AZURE_CLIENT_ID }}",
              "clientSecret": "${{ secrets.AZURE_CLIENT_SECRET }}",
              "subscriptionId": "${{ secrets.AZURE_SUBSCRIPTION_ID }}",
              "tenantId": "${{ secrets.AZURE_TENANT_ID }}"
            }

      - name: Get AKS credentials
        run: |
          if [ -z "${{ secrets.AKS_NAME }}" ]; then
            echo "ERROR: secret AKS_NAME is not set. Please add repository or environment secret 'AKS_NAME' with your AKS cluster name.";
            exit 1;
          fi
          if [ -z "${{ secrets.AKS_RG }}" ]; then
            echo "ERROR: secret AKS_RG is not set. Please add repository or environment secret 'AKS_RG' with your AKS resource group name.";
            exit 1;
          fi
          echo "Getting credentials for AKS cluster: ${{ secrets.AKS_NAME }} in RG: ${{ secrets.AKS_RG }}"
          az aks get-credentials --resource-group "${{ secrets.AKS_RG }}" --name "${{ secrets.AKS_NAME }}" --overwrite-existing
          echo "Current context:"
          kubectl config current-context
          echo "Cluster nodes:"
          kubectl get nodes --no-headers | wc -l
          echo "nodes available"

      - name: Install kubectl
        uses: azure/setup-kubectl@v3

      - name: Install Helm
        uses: azure/setup-helm@v4
        with:
          version: 'latest'

      - name: Create namespace
        run: |
          kubectl create namespace ecommerce-dev --dry-run=client -o yaml | kubectl apply -f -
          echo "Namespace ecommerce-dev ready"
          kubectl get namespace ecommerce-dev

      - name: Create GHCR secret (if provided)
        run: |
          if [ -n "${{ secrets.GHCR_TOKEN }}" ]; then \
            kubectl create secret docker-registry ghcr-secret --docker-server=ghcr.io --docker-username=${{ secrets.GHCR_USERNAME }} --docker-password=${{ secrets.GHCR_TOKEN }} --namespace=ecommerce-dev || true; \
          else \
            echo "GHCR_TOKEN not provided, skipping secret creation"; \
          fi

      - name: Check and cleanup failed releases
        working-directory: k8s/helm
        run: |
          echo "Checking for existing releases..."
          if helm list -n ecommerce-dev | grep -q ecommerce-microservices; then
            RELEASE_STATUS=$(helm status ecommerce-microservices -n ecommerce-dev -o json | jq -r '.info.status')
            echo "Found release with status: $RELEASE_STATUS"
            if [ "$RELEASE_STATUS" = "failed" ] || [ "$RELEASE_STATUS" = "pending-install" ] || [ "$RELEASE_STATUS" = "pending-upgrade" ]; then
              echo "Cleaning up failed/pending release..."
              helm uninstall ecommerce-microservices -n ecommerce-dev || true
              sleep 5
            fi
          else
            echo "No existing release found"
          fi

      - name: Deploy Helm chart
        working-directory: k8s/helm
        run: |
          echo "Deploying Helm chart to namespace ecommerce-dev..."
          
          # Detectar qu√© servicios cambiaron en este push
          echo "üîç Detecting changed services..."
          CHANGED_SERVICES=""
          
          # Mapeo de directorios a nombres de servicios
          if git diff --name-only HEAD~1 HEAD | grep -q "^api-gateway/"; then
            CHANGED_SERVICES="$CHANGED_SERVICES api-gateway"
          fi
          if git diff --name-only HEAD~1 HEAD | grep -q "^cloud-config/"; then
            CHANGED_SERVICES="$CHANGED_SERVICES cloud-config"
          fi
          if git diff --name-only HEAD~1 HEAD | grep -q "^service-discovery/"; then
            CHANGED_SERVICES="$CHANGED_SERVICES service-discovery"
          fi
          if git diff --name-only HEAD~1 HEAD | grep -q "^user-service/"; then
            CHANGED_SERVICES="$CHANGED_SERVICES user-service"
          fi
          if git diff --name-only HEAD~1 HEAD | grep -q "^product-service/"; then
            CHANGED_SERVICES="$CHANGED_SERVICES product-service"
          fi
          if git diff --name-only HEAD~1 HEAD | grep -q "^order-service/"; then
            CHANGED_SERVICES="$CHANGED_SERVICES order-service"
          fi
          if git diff --name-only HEAD~1 HEAD | grep -q "^payment-service/"; then
            CHANGED_SERVICES="$CHANGED_SERVICES payment-service"
          fi
          if git diff --name-only HEAD~1 HEAD | grep -q "^shipping-service/"; then
            CHANGED_SERVICES="$CHANGED_SERVICES shipping-service"
          fi
          if git diff --name-only HEAD~1 HEAD | grep -q "^favourite-service/"; then
            CHANGED_SERVICES="$CHANGED_SERVICES favourite-service"
          fi
          if git diff --name-only HEAD~1 HEAD | grep -q "^proxy-client/"; then
            CHANGED_SERVICES="$CHANGED_SERVICES proxy-client"
          fi
          
          if [ -z "$CHANGED_SERVICES" ]; then
            echo "‚ö†Ô∏è  No service changes detected, deploying with existing tags"
            helm upgrade --install ecommerce-microservices ./ecommerce-chart \
              --namespace ecommerce-dev \
              --values ./ecommerce-chart/values.yaml \
              --values ./image-tags-dev.yaml \
              --set global.environment=${{ env.ENVIRONMENT }} \
              --wait \
              --timeout 20m
          else
            echo "üì¶ Changed services: $CHANGED_SERVICES"
            
            # Generar un valor √∫nico para forzar rollout SOLO de los servicios cambiados
            ROLLOUT_ID=$(date +%s)-${GITHUB_SHA::7}
            
            # Construir los argumentos --set para cada servicio cambiado
            SET_ARGS=""
            for SERVICE in $CHANGED_SERVICES; do
              # Para los servicios cambiados, agregar anotaci√≥n de rollout
              SET_ARGS="$SET_ARGS --set-string microservices[$SERVICE].rolloutId=$ROLLOUT_ID"
            done
            
            echo "üîÑ Rollout ID for changed services: $ROLLOUT_ID"
            
            # Deploy con Helm
            helm upgrade --install ecommerce-microservices ./ecommerce-chart \
              --namespace ecommerce-dev \
              --values ./ecommerce-chart/values.yaml \
              --values ./image-tags-dev.yaml \
              --set global.environment=${{ env.ENVIRONMENT }} \
              $SET_ARGS \
              --wait \
              --timeout 20m
          fi

      - name: Verify deployment
        if: always()
        run: |
          echo "=== Helm Release Status ==="
          helm status ecommerce-microservices -n ecommerce-dev || echo "Release not found"
          echo ""
          echo "=== Pods Status ==="
          kubectl get pods -n ecommerce-dev -o wide
          echo ""
          echo "=== Services ==="
          kubectl get svc -n ecommerce-dev
          echo ""
          echo "=== Recent Events ==="
          kubectl get events -n ecommerce-dev --sort-by='.lastTimestamp' | tail -n 20
